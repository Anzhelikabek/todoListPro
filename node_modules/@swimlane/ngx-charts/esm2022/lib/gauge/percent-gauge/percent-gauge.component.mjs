import { Component, Input, ViewEncapsulation, ChangeDetectionStrategy, ViewChild } from '@angular/core';
import { GradientPath } from 'gradient-path';
import { BaseChartComponent } from '../../common/base-chart.component';
import { calculateViewDimensions } from '../../common/view-dimensions.helper';
import { ColorHelper } from '../../common/color.helper';
import { ScaleType } from '../../common/types/scale-type.enum';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../../common/charts/chart.component";
export class PercentGaugeComponent extends BaseChartComponent {
    constructor() {
        super(...arguments);
        this.max = 100;
        this.value = 0;
        this.target = 75;
        this.targetLabel = 'Target';
        this.showLabel = true;
        this.defaultMargin = [20, 40, 20, 40];
        this.margin = [20, 40, 20, 40];
        this.ticks = [];
    }
    update() {
        super.update();
        this.margin = [...this.defaultMargin];
        if (this.showLabel) {
            this.margin[2] = 50;
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.percent = this.getPercentage();
        this.ticHeight = Math.min(this.dims.width, this.dims.height) / 10;
        this.radius = Math.min(this.dims.width, this.dims.height) / 2 - this.ticHeight / 2;
        this.circumference = 2 * Math.PI * this.radius;
        this.dashes = `${this.radius / 60} ${this.circumference / 60 - this.radius / 60}`;
        this.valueFontSize = Math.floor(this.radius / 3);
        this.targetRadius = this.radius / 4;
        this.targetTextTransform = `translate(${-this.targetRadius / 2}, ${-this.targetRadius / 2}), scale(${this.targetRadius / 28})`;
        this.valueDomain = this.getValueDomain();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        this.targetColor = this.colors.getColor((this.target / 100) * this.max);
        const xOffset = this.margin[3] + this.dims.width / 2;
        const yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = `translate(${xOffset}, ${yOffset})`;
        this.labelTransform = `translate(0, ${this.height / 2 + this.radius + this.margin[0] + this.ticHeight / 2 - 3})`;
        const angle = (this.target / 100) * Math.PI * 2 - Math.PI / 2;
        this.targetTransform = `translate(${this.radius * 0.97 * Math.cos(angle) + this.targetRadius / 2}, ${this.radius * 0.97 * Math.sin(angle) + this.targetRadius / 2})`;
        this.generateticks();
        this.cd.markForCheck();
    }
    generateticks() {
        if (this.circleElement?.nativeElement) {
            const clonedCircle = this.circleElement.nativeElement.cloneNode(true);
            clonedCircle.setAttribute('stroke-width', this.radius / 5);
            clonedCircle.setAttribute('r', this.radius);
            this.circleElement.nativeElement.parentElement.appendChild(clonedCircle);
            try {
                const gp = new GradientPath({
                    path: clonedCircle,
                    segments: 60,
                    samples: 2,
                    precision: 2
                });
                clonedCircle.remove();
                const data = gp.data.flatMap(({ samples }) => samples);
                this.ticks = [];
                this.circleTransform = `rotate(-90,0,0)`;
                for (let j = 0; j < data.length; j++) {
                    const { x, y } = data[j];
                    let progress = data[j].progress;
                    if (progress === 1) {
                        progress = 0;
                    }
                    this.ticks.push({
                        height: this.ticHeight,
                        width: this.radius / 60,
                        fill: this.colors.getColor(progress * this.max),
                        transform: `translate(${x}, ${y}), rotate(${360 * progress - 90})`
                    });
                }
            }
            catch (e) {
                console.log('Unable to generate ticks for percent gauge chart', e);
            }
            finally {
                clonedCircle.remove();
            }
        }
    }
    getValueDomain() {
        return [0, this.max];
    }
    getDisplayValue() {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.percent + '%';
    }
    getPercentage() {
        return Math.round((this.value / this.max) * 100);
    }
    onClick() {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    }
    setColors() {
        this.colors = new ColorHelper(this.scheme, ScaleType.Linear, this.valueDomain, this.customColors);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PercentGaugeComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: PercentGaugeComponent, selector: "ngx-charts-percent-gauge", inputs: { max: "max", value: "value", target: "target", targetLabel: "targetLabel", label: "label", valueFormatting: "valueFormatting", showLabel: "showLabel" }, viewQueries: [{ propertyName: "circleElement", first: true, predicate: ["circleEl"], descendants: true }], usesInheritance: true, ngImport: i0, template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g class="percent-gauge chart" (click)="onClick()">
        <svg:g [attr.transform]="transform">
          <mask id="circleMask">
            <circle
              [attr.r]="radius"
              [style.stroke-width]="radius / 5"
              cx="0"
              cy="0"
              stroke="white"
              fill="transparent"
              [attr.stroke-dasharray]="circumference"
              transform="rotate(-90,0,0)"
              [style.stroke-dashoffset]="circumference * (1 - percent / 100)"
            />
          </mask>
          <text x="0" y="0" fill="white" stroke="none" class="total" [style.font-size]="valueFontSize">
            {{ displayValue }}
          </text>
          <circle
            #circleEl
            class="dashes-back"
            [style.stroke-width]="radius / 5"
            [attr.r]="radius"
            cx="0"
            cy="0"
            fill="none"
            [style.stroke-dasharray]="dashes"
          />

          <svg:g mask="url(#circleMask)">
            <svg:g [attr.transform]="circleTransform">
              <svg:g *ngFor="let tic of ticks" [attr.transform]="tic.transform">
                <rect
                  [attr.y]="-tic.height / 2"
                  [attr.x]="-tic.width"
                  [attr.width]="tic.width"
                  [attr.height]="tic.height"
                  [attr.fill]="tic.fill"
                />
              </svg:g>
            </svg:g>
          </svg:g>

          <svg:g [attr.transform]="targetTransform">
            <circle
              class="target-circle"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.stroke]="targetColor"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <svg:g [attr.transform]="targetTextTransform">
              <text
                transform="translate(0, -4)"
                class="target-label"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="12"
              >
                {{ targetLabel }}
              </text>
              <text
                transform="translate(0, 11)"
                class="target-value"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="14"
              >
                {{ target }}%
              </text>
            </svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="showLabel" [attr.transform]="labelTransform">
          <text class="gauge-label" x="50%" dominant-baseline="middle" text-anchor="middle" stroke="none">
            {{ label }}
          </text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, isInline: true, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#455066}.percent-gauge .target-circle{fill:#1b1e27}.percent-gauge .target-label{fill:#a0aabe}.percent-gauge .target-value{fill:#cdd2dd}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.ChartComponent, selector: "ngx-charts-chart", inputs: ["view", "showLegend", "legendOptions", "legendType", "activeEntries", "animations"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PercentGaugeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-charts-percent-gauge', template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g class="percent-gauge chart" (click)="onClick()">
        <svg:g [attr.transform]="transform">
          <mask id="circleMask">
            <circle
              [attr.r]="radius"
              [style.stroke-width]="radius / 5"
              cx="0"
              cy="0"
              stroke="white"
              fill="transparent"
              [attr.stroke-dasharray]="circumference"
              transform="rotate(-90,0,0)"
              [style.stroke-dashoffset]="circumference * (1 - percent / 100)"
            />
          </mask>
          <text x="0" y="0" fill="white" stroke="none" class="total" [style.font-size]="valueFontSize">
            {{ displayValue }}
          </text>
          <circle
            #circleEl
            class="dashes-back"
            [style.stroke-width]="radius / 5"
            [attr.r]="radius"
            cx="0"
            cy="0"
            fill="none"
            [style.stroke-dasharray]="dashes"
          />

          <svg:g mask="url(#circleMask)">
            <svg:g [attr.transform]="circleTransform">
              <svg:g *ngFor="let tic of ticks" [attr.transform]="tic.transform">
                <rect
                  [attr.y]="-tic.height / 2"
                  [attr.x]="-tic.width"
                  [attr.width]="tic.width"
                  [attr.height]="tic.height"
                  [attr.fill]="tic.fill"
                />
              </svg:g>
            </svg:g>
          </svg:g>

          <svg:g [attr.transform]="targetTransform">
            <circle
              class="target-circle"
              [attr.r]="targetRadius"
              [style.stroke-width]="targetRadius / 10"
              [attr.stroke]="targetColor"
              [attr.cx]="-targetRadius / 2"
              [attr.cy]="-targetRadius / 2"
            />
            <svg:g [attr.transform]="targetTextTransform">
              <text
                transform="translate(0, -4)"
                class="target-label"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="12"
              >
                {{ targetLabel }}
              </text>
              <text
                transform="translate(0, 11)"
                class="target-value"
                stroke="none"
                text-anchor="middle"
                [style.font-size]="14"
              >
                {{ target }}%
              </text>
            </svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="showLabel" [attr.transform]="labelTransform">
          <text class="gauge-label" x="50%" dominant-baseline="middle" text-anchor="middle" stroke="none">
            {{ label }}
          </text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".percent-gauge{cursor:pointer}.percent-gauge text{text-anchor:middle}.percent-gauge .dashes-back{stroke:#455066}.percent-gauge .target-circle{fill:#1b1e27}.percent-gauge .target-label{fill:#a0aabe}.percent-gauge .target-value{fill:#cdd2dd}.percent-gauge .total{dominant-baseline:middle}.percent-gauge .label{display:block;text-anchor:middle}\n"] }]
        }], propDecorators: { max: [{
                type: Input
            }], value: [{
                type: Input
            }], target: [{
                type: Input
            }], targetLabel: [{
                type: Input
            }], label: [{
                type: Input
            }], valueFormatting: [{
                type: Input
            }], showLabel: [{
                type: Input
            }], circleElement: [{
                type: ViewChild,
                args: ['circleEl']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyY2VudC1nYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zd2ltbGFuZS9uZ3gtY2hhcnRzL3NyYy9saWIvZ2F1Z2UvcGVyY2VudC1nYXVnZS9wZXJjZW50LWdhdWdlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBYyxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEgsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFeEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9DQUFvQyxDQUFDOzs7O0FBNEYvRCxNQUFNLE9BQU8scUJBQXNCLFNBQVEsa0JBQWtCO0lBMUY3RDs7UUEyRlcsUUFBRyxHQUFXLEdBQUcsQ0FBQztRQUNsQixVQUFLLEdBQVcsQ0FBQyxDQUFDO1FBQ2xCLFdBQU0sR0FBVyxFQUFFLENBQUM7UUFDcEIsZ0JBQVcsR0FBVyxRQUFRLENBQUM7UUFHL0IsY0FBUyxHQUFHLElBQUksQ0FBQztRQUkxQixrQkFBYSxHQUFhLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDM0MsV0FBTSxHQUFhLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFhcEMsVUFBSyxHQUFVLEVBQUUsQ0FBQztLQWdJbkI7SUFuSEMsTUFBTTtRQUNKLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUVmLElB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Ozs7R0FtRlQsaUJBRWMsaUJBQWlCLENBQUMsSUFBSSxtQkFDcEIsdUJBQXVCLENBQUMsTUFBTTs4QkFHdEMsR0FBRztzQkFBWCxLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csV0FBVztzQkFBbkIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxTQUFTO3NCQUFqQixLQUFLO2dCQUVpQixhQUFhO3NCQUFuQyxTQUFTO3VCQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3JhZGllbnRQYXRoIH0gZnJvbSAnZ3JhZGllbnQtcGF0aCc7XG5cbmltcG9ydCB7IEJhc2VDaGFydENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbW1vbi9iYXNlLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2NvbW1vbi92aWV3LWRpbWVuc2lvbnMuaGVscGVyJztcbmltcG9ydCB7IENvbG9ySGVscGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL2NvbG9yLmhlbHBlcic7XG5pbXBvcnQgeyBWaWV3RGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2NvbW1vbi90eXBlcy92aWV3LWRpbWVuc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vY29tbW9uL3R5cGVzL3NjYWxlLXR5cGUuZW51bSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1jaGFydHMtcGVyY2VudC1nYXVnZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVwiW3dpZHRoLCBoZWlnaHRdXCIgW3Nob3dMZWdlbmRdPVwiZmFsc2VcIiBbYW5pbWF0aW9uc109XCJhbmltYXRpb25zXCI+XG4gICAgICA8c3ZnOmcgY2xhc3M9XCJwZXJjZW50LWdhdWdlIGNoYXJ0XCIgKGNsaWNrKT1cIm9uQ2xpY2soKVwiPlxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cInRyYW5zZm9ybVwiPlxuICAgICAgICAgIDxtYXNrIGlkPVwiY2lyY2xlTWFza1wiPlxuICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICBbYXR0ci5yXT1cInJhZGl1c1wiXG4gICAgICAgICAgICAgIFtzdHlsZS5zdHJva2Utd2lkdGhdPVwicmFkaXVzIC8gNVwiXG4gICAgICAgICAgICAgIGN4PVwiMFwiXG4gICAgICAgICAgICAgIGN5PVwiMFwiXG4gICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbiAgICAgICAgICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgICAgW2F0dHIuc3Ryb2tlLWRhc2hhcnJheV09XCJjaXJjdW1mZXJlbmNlXCJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtPVwicm90YXRlKC05MCwwLDApXCJcbiAgICAgICAgICAgICAgW3N0eWxlLnN0cm9rZS1kYXNob2Zmc2V0XT1cImNpcmN1bWZlcmVuY2UgKiAoMSAtIHBlcmNlbnQgLyAxMDApXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9tYXNrPlxuICAgICAgICAgIDx0ZXh0IHg9XCIwXCIgeT1cIjBcIiBmaWxsPVwid2hpdGVcIiBzdHJva2U9XCJub25lXCIgY2xhc3M9XCJ0b3RhbFwiIFtzdHlsZS5mb250LXNpemVdPVwidmFsdWVGb250U2l6ZVwiPlxuICAgICAgICAgICAge3sgZGlzcGxheVZhbHVlIH19XG4gICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICNjaXJjbGVFbFxuICAgICAgICAgICAgY2xhc3M9XCJkYXNoZXMtYmFja1wiXG4gICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoXT1cInJhZGl1cyAvIDVcIlxuICAgICAgICAgICAgW2F0dHIucl09XCJyYWRpdXNcIlxuICAgICAgICAgICAgY3g9XCIwXCJcbiAgICAgICAgICAgIGN5PVwiMFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheV09XCJkYXNoZXNcIlxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8c3ZnOmcgbWFzaz1cInVybCgjY2lyY2xlTWFzaylcIj5cbiAgICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVwiY2lyY2xlVHJhbnNmb3JtXCI+XG4gICAgICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgdGljIG9mIHRpY2tzXCIgW2F0dHIudHJhbnNmb3JtXT1cInRpYy50cmFuc2Zvcm1cIj5cbiAgICAgICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICAgICAgW2F0dHIueV09XCItdGljLmhlaWdodCAvIDJcIlxuICAgICAgICAgICAgICAgICAgW2F0dHIueF09XCItdGljLndpZHRoXCJcbiAgICAgICAgICAgICAgICAgIFthdHRyLndpZHRoXT1cInRpYy53aWR0aFwiXG4gICAgICAgICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVwidGljLmhlaWdodFwiXG4gICAgICAgICAgICAgICAgICBbYXR0ci5maWxsXT1cInRpYy5maWxsXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L3N2ZzpnPlxuICAgICAgICAgICAgPC9zdmc6Zz5cbiAgICAgICAgICA8L3N2ZzpnPlxuXG4gICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XCJ0YXJnZXRUcmFuc2Zvcm1cIj5cbiAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgY2xhc3M9XCJ0YXJnZXQtY2lyY2xlXCJcbiAgICAgICAgICAgICAgW2F0dHIucl09XCJ0YXJnZXRSYWRpdXNcIlxuICAgICAgICAgICAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoXT1cInRhcmdldFJhZGl1cyAvIDEwXCJcbiAgICAgICAgICAgICAgW2F0dHIuc3Ryb2tlXT1cInRhcmdldENvbG9yXCJcbiAgICAgICAgICAgICAgW2F0dHIuY3hdPVwiLXRhcmdldFJhZGl1cyAvIDJcIlxuICAgICAgICAgICAgICBbYXR0ci5jeV09XCItdGFyZ2V0UmFkaXVzIC8gMlwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XCJ0YXJnZXRUZXh0VHJhbnNmb3JtXCI+XG4gICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsIC00KVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0YXJnZXQtbGFiZWxcIlxuICAgICAgICAgICAgICAgIHN0cm9rZT1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHRleHQtYW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICBbc3R5bGUuZm9udC1zaXplXT1cIjEyXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt7IHRhcmdldExhYmVsIH19XG4gICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwgMTEpXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhcmdldC12YWx1ZVwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgdGV4dC1hbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5mb250LXNpemVdPVwiMTRcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3sgdGFyZ2V0IH19JVxuICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICA8L3N2ZzpnPlxuICAgICAgICAgIDwvc3ZnOmc+XG4gICAgICAgIDwvc3ZnOmc+XG4gICAgICAgIDxzdmc6ZyAqbmdJZj1cInNob3dMYWJlbFwiIFthdHRyLnRyYW5zZm9ybV09XCJsYWJlbFRyYW5zZm9ybVwiPlxuICAgICAgICAgIDx0ZXh0IGNsYXNzPVwiZ2F1Z2UtbGFiZWxcIiB4PVwiNTAlXCIgZG9taW5hbnQtYmFzZWxpbmU9XCJtaWRkbGVcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIHN0cm9rZT1cIm5vbmVcIj5cbiAgICAgICAgICAgIHt7IGxhYmVsIH19XG4gICAgICAgICAgPC90ZXh0PlxuICAgICAgICA8L3N2ZzpnPlxuICAgICAgPC9zdmc6Zz5cbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XG4gIGAsXG4gIHN0eWxlVXJsczogWycuLi8uLi9jb21tb24vYmFzZS1jaGFydC5jb21wb25lbnQuc2NzcycsICcuL3BlcmNlbnQtZ2F1Z2UuY29tcG9uZW50LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUGVyY2VudEdhdWdlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNoYXJ0Q29tcG9uZW50IHtcbiAgQElucHV0KCkgbWF4OiBudW1iZXIgPSAxMDA7XG4gIEBJbnB1dCgpIHZhbHVlOiBudW1iZXIgPSAwO1xuICBASW5wdXQoKSB0YXJnZXQ6IG51bWJlciA9IDc1O1xuICBASW5wdXQoKSB0YXJnZXRMYWJlbDogc3RyaW5nID0gJ1RhcmdldCc7XG4gIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHZhbHVlRm9ybWF0dGluZzogYW55O1xuICBASW5wdXQoKSBzaG93TGFiZWwgPSB0cnVlO1xuXG4gIEBWaWV3Q2hpbGQoJ2NpcmNsZUVsJykgY2lyY2xlRWxlbWVudDogRWxlbWVudFJlZjtcblxuICBkZWZhdWx0TWFyZ2luOiBudW1iZXJbXSA9IFsyMCwgNDAsIDIwLCA0MF07XG4gIG1hcmdpbjogbnVtYmVyW10gPSBbMjAsIDQwLCAyMCwgNDBdO1xuICBkaW1zOiBWaWV3RGltZW5zaW9ucztcblxuICBjb2xvcnM6IENvbG9ySGVscGVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgdHJhbnNmb3JtOiBzdHJpbmc7XG5cbiAgdGFyZ2V0VHJhbnNmb3JtOiBzdHJpbmc7XG4gIHRhcmdldENvbG9yOiBzdHJpbmc7XG4gIHRhcmdldFJhZGl1czogbnVtYmVyO1xuICB0YXJnZXRUZXh0VHJhbnNmb3JtOiBzdHJpbmc7XG5cbiAgY2lyY2xlVHJhbnNmb3JtOiBzdHJpbmc7XG4gIHRpY2tzOiBhbnlbXSA9IFtdO1xuICB0aWNIZWlnaHQ6IG51bWJlcjtcblxuICBkYXNoZXM6IHN0cmluZztcblxuICB2YWx1ZURvbWFpbjogW251bWJlciwgbnVtYmVyXTtcbiAgdmFsdWVGb250U2l6ZTogbnVtYmVyO1xuICBkaXNwbGF5VmFsdWU6IHN0cmluZztcbiAgcGVyY2VudDogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG5cbiAgbGFiZWxUcmFuc2Zvcm06IHN0cmluZztcblxuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICB0aGlzLm1hcmdpbiA9IFsuLi50aGlzLmRlZmF1bHRNYXJnaW5dO1xuICAgIGlmICh0aGlzLnNob3dMYWJlbCkge1xuICAgICAgdGhpcy5tYXJnaW5bMl0gPSA1MDtcbiAgICB9XG5cbiAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxuICAgIH0pO1xuXG4gICAgdGhpcy5wZXJjZW50ID0gdGhpcy5nZXRQZXJjZW50YWdlKCk7XG4gICAgdGhpcy50aWNIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuZGltcy5oZWlnaHQpIC8gMTA7XG4gICAgdGhpcy5yYWRpdXMgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuZGltcy5oZWlnaHQpIC8gMiAtIHRoaXMudGljSGVpZ2h0IC8gMjtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMucmFkaXVzO1xuICAgIHRoaXMuZGFzaGVzID0gYCR7dGhpcy5yYWRpdXMgLyA2MH0gJHt0aGlzLmNpcmN1bWZlcmVuY2UgLyA2MCAtIHRoaXMucmFkaXVzIC8gNjB9YDtcbiAgICB0aGlzLnZhbHVlRm9udFNpemUgPSBNYXRoLmZsb29yKHRoaXMucmFkaXVzIC8gMyk7XG4gICAgdGhpcy50YXJnZXRSYWRpdXMgPSB0aGlzLnJhZGl1cyAvIDQ7XG4gICAgdGhpcy50YXJnZXRUZXh0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkey10aGlzLnRhcmdldFJhZGl1cyAvIDJ9LCAkey10aGlzLnRhcmdldFJhZGl1cyAvIDJ9KSwgc2NhbGUoJHtcbiAgICAgIHRoaXMudGFyZ2V0UmFkaXVzIC8gMjhcbiAgICB9KWA7XG5cbiAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xuICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5nZXREaXNwbGF5VmFsdWUoKTtcblxuICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgdGhpcy50YXJnZXRDb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKCh0aGlzLnRhcmdldCAvIDEwMCkgKiB0aGlzLm1heCk7XG5cbiAgICBjb25zdCB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5bM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSB0aGlzLm1hcmdpblswXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7eE9mZnNldH0sICR7eU9mZnNldH0pYDtcbiAgICB0aGlzLmxhYmVsVHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgwLCAke3RoaXMuaGVpZ2h0IC8gMiArIHRoaXMucmFkaXVzICsgdGhpcy5tYXJnaW5bMF0gKyB0aGlzLnRpY0hlaWdodCAvIDIgLSAzfSlgO1xuXG4gICAgY29uc3QgYW5nbGUgPSAodGhpcy50YXJnZXQgLyAxMDApICogTWF0aC5QSSAqIDIgLSBNYXRoLlBJIC8gMjtcbiAgICB0aGlzLnRhcmdldFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0aGlzLnJhZGl1cyAqIDAuOTcgKiBNYXRoLmNvcyhhbmdsZSkgKyB0aGlzLnRhcmdldFJhZGl1cyAvIDJ9LCAke1xuICAgICAgdGhpcy5yYWRpdXMgKiAwLjk3ICogTWF0aC5zaW4oYW5nbGUpICsgdGhpcy50YXJnZXRSYWRpdXMgLyAyXG4gICAgfSlgO1xuXG4gICAgdGhpcy5nZW5lcmF0ZXRpY2tzKCk7XG5cbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgZ2VuZXJhdGV0aWNrcygpIHtcbiAgICBpZiAodGhpcy5jaXJjbGVFbGVtZW50Py5uYXRpdmVFbGVtZW50KSB7XG4gICAgICBjb25zdCBjbG9uZWRDaXJjbGUgPSB0aGlzLmNpcmNsZUVsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBjbG9uZWRDaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnJhZGl1cyAvIDUpO1xuICAgICAgY2xvbmVkQ2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIHRoaXMucmFkaXVzKTtcblxuICAgICAgdGhpcy5jaXJjbGVFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZWRDaXJjbGUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBncCA9IG5ldyBHcmFkaWVudFBhdGgoe1xuICAgICAgICAgIHBhdGg6IGNsb25lZENpcmNsZSxcbiAgICAgICAgICBzZWdtZW50czogNjAsXG4gICAgICAgICAgc2FtcGxlczogMixcbiAgICAgICAgICBwcmVjaXNpb246IDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xvbmVkQ2lyY2xlLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBncC5kYXRhLmZsYXRNYXAoKHsgc2FtcGxlcyB9KSA9PiBzYW1wbGVzKTtcbiAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNpcmNsZVRyYW5zZm9ybSA9IGByb3RhdGUoLTkwLDAsMClgO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGRhdGFbal07XG4gICAgICAgICAgbGV0IHByb2dyZXNzID0gZGF0YVtqXS5wcm9ncmVzcztcbiAgICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgICAgIHByb2dyZXNzID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRpY2tzLnB1c2goe1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnRpY0hlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJhZGl1cyAvIDYwLFxuICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvcnMuZ2V0Q29sb3IocHJvZ3Jlc3MgKiB0aGlzLm1heCksXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4fSwgJHt5fSksIHJvdGF0ZSgkezM2MCAqIHByb2dyZXNzIC0gOTB9KWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGdlbmVyYXRlIHRpY2tzIGZvciBwZXJjZW50IGdhdWdlIGNoYXJ0JywgZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbG9uZWRDaXJjbGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0VmFsdWVEb21haW4oKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIFswLCB0aGlzLm1heF07XG4gIH1cblxuICBnZXREaXNwbGF5VmFsdWUoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGVyY2VudCArICclJztcbiAgfVxuXG4gIGdldFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy52YWx1ZSAvIHRoaXMubWF4KSAqIDEwMCk7XG4gIH1cblxuICBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0LmVtaXQoe1xuICAgICAgbmFtZTogJ1ZhbHVlJyxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBzZXRDb2xvcnMoKTogdm9pZCB7XG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIFNjYWxlVHlwZS5MaW5lYXIsIHRoaXMudmFsdWVEb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgfVxufVxuIl19